<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>js的对象学习</title>
</head>
<body>

<script>
    /*js中的对象
字符串，函数，数组，这些都是对象*/

    /*    内置对象：指的是浏览器封装好的一些对象，我们可以直接调用它的属性以及方法等东西。
        属性：这个对象的一个特性
        方法：对象作用

        四个主要的内置对象学习
        1、数组array,切片slice

        2、字符串string
        3、math
        4、Date
    */


    /* 一、数组
          js中的数组跟其他语言的数组是有区别的，
          ①在同一个数组中，元素的类型可以不一样，可以是任意类型。
          ②js中的数组的长度是动态的，可以改变的。
          为什么要创建成为数组，就是要存储一组数据。个数肯定就是大于等于2！！！！！！！！！

         //1、创建数组
                        方法1：使用array构造函数，
                              语法：new Array()   ,支持只写Array()，但是不建议这么偷懒，谁知道什么时候代码会发生什么错误呢
                              ()说明：
                                 ①如果我们预先知道这个数组需要放置的元素数量，那么会在这个括号里写上这个数量数值，
                                 ②向Array构造函数中传递数组应该包含的项。就是把数组元素写出来，
                         */


                         /*创建一个保存颜色的数组
                        var colors = new Array();  //这里表示创建一个空的数组
                        console.log(colors); //在控制台就可以看到一个[]表示一个空的数组
                        var colors1 = new Array(3);  //这里表示创建一个长度为3的的数组
                        var numbers = new Array(1, 4, 6, 3);//这里表示创建一个元素为 1  4  6  3*/


                  /*
                     方法2：使用字面量来创建数组
                        语法：就是在一个中括号[]
                        面吧元素列举出来，元素之间用逗号隔开。*!/
                        var colors2 = ["red", "yellow", "blue"];
                        console.log(colors2); // ["red","yellow","blue"]
                        var infos = ["1114010202", "china", 18, true, {email: "liuxiaomi0724@163.com"}]
                        console.log(infos); //["1114010202", "china", 18, true, {…}]    是{…}，不是视频说的object啊？？？？？*/


/*          //2、  读取元素：通过索引来读取元素
                        var infos = ["1114010202", "china", 18, true, {email: "liuxiaomi0724@163.com"}]
                        console.log(infos); //["1114010202", "china", 18, true, {…}]    是{…}，不是视频说的object啊？？？？？
                        console.log(infos[0]);  // "1114010202"
                        console.log(infos[5]);  // undefined

           //3、获取数组长度;语法：Array.length   返回number
                        console.log(infos.length) ;// 5
                         // 说明：通过设置数组的length可以移除数组的末尾项（元素），或者向数组中添加新的项
                        infos.length=3;  //把infos数组的长度更新为3，那么它就会把第4个以后后面的想都移除。
                        console.log(infos);//["1114010202", "china", 18]  得到了一个新的数组了
                        infos.length=5;  //把infos数组的长度更新为5，往里面添加2个项目，但是是回不到之前的，添加的只是空项，没有值的项
                        console.log(infos);//["1114010202", "china", 18, empty × 2]
                         //当我们把一个值放在当前数组大小的位置上时，会重新计算数组的长度，长度值与索引页相应的+1，，，，这句话屁用，复杂化
                         infos[99]=2;  // 把2赋值给索引为99的数组元素，数组的长度就更新了，
                        console.log(infos.length);//100    索引到99了，就有100个元素了，*/


 /*         //4、数组的遍历:拿到数组中的每个元素的值
                        // 用for循环来遍历已经知道个数的数组
                        var str=["a","b","c","d","e"];
                        var len=str.length;
                        for(var i=0;i<len;i++){
                            console.log(str[i]);
                        }*/

/*//5、数组的方法：栈方法?????????????????????????????????????????????????????//
                    ①、push()   给数组尾部添加元素 ，返回新的长度值number               //翻译：push，推动，增加，对什么施加压力
                                                      也返回一个新的数组啊！！
                                 语法： arrayObject.push(元素1，元素2，，，，，元素n)！！！！！！就是   数组名.push（被添加上去的元素），说那么复杂干嘛！！！
                                 功能： 把它的参数有顺序的添加到arrayObject的尾部
                                 返回值：把指定的值(元素1，元素2，，，，，元素n)添加到数组之后的新的长度值，number
                    ②、unshift() 给数组前端添加元素,返回新的长度值number                // 翻译：unshift 不去掉，就是往上添加
                                                     也返回一个新的数组啊
                    ③、pop()     删除数组的最后一个元素，返回最后一个元素值，           //翻译：pop 突然提出，突然拿出来，突然出现，发出爆裂声，就是拿掉
                                  语法：var info=colors.pop();
                    ④、shift()// 删除数组的第一一个元素，返回第一个元素值，          // 翻译：shif去掉，改变，摆脱掉，换衣服，更衣，
                                                                                         //       还有换挡，上档键的意思，那就是数组前端咯！！！
                    ⑤、join(),把数组的所有元素放入一个字符串，返回新字符串           //翻译：join，参加，加入
                               （）中写的是分隔符
                    ⑥、reverse(),把数组倒序，返回新的数组                            //翻译：reverse，反转，点到，交换，推翻
                    ⑦、sort(),   把数组按照要求排序，返回新的数组
                                   sort比较的是字符串，不是数值，即使数组全都是数值，比较的也是字符串
                                   ()内可以接收一个比较函数作为参数
                    ⑧concat() ,   在一个数组后面连接数组（多个数组都行），返回一个新的数组，
                    ⑨slice(m,n),   在一个数组中取值，返回新的数组，就是切片咯！！
                                    如果是正数从头部开始算，是负数就从尾部开始算，   取的区间都是从左往右m的位置元素到n的位置元素，不包括n的位置元素,
                                    负数的话：最后一个元素就是-1，不是0
                                    区间是开闭区间，包含索引m，但是不包含n！！！！！！！！！！！！！
                                    参数为负值，则该参数是从数组的末尾索引开始算起的（-1指的是数组中倒数第一个元素）；
                                    参数只有一个时-——slice（2），表示的是从下标为2位置的元素提取到末尾；
                                    参数是0时，——slice()，表示的是全部提取，相当于克隆一个新的数组，克隆后两数组之间进行各自的操作，互不影响；
                     ⑩splice(m,len,要插入的元素item1...itemn)    从m索引这个元素开始，删除len个元素，并且带上要插入的元素，（）
                                                   所以，n=0时表示不删除元素，
                                                   没有item的时候就是不插入元素
                                                    在数组中某处插入值，返回新的数组（被删除的元素组成的新数组），并且原数组会被改变
                                                    替换数组的某个元素，返回新的数组（被删除/替换的元素组成的新数组），并且原数组会被改变
                     ⑪ indexOf(要查找的元素searchvalue，开始查找的索引startindex) ，  从头开始查找，从左往右
                                                 从starindex开始查找元素的，第一次找到元素的下标
                                                返回下标值，不会改变原数组

                     ⑫lastIndexOf(要查找的元素searchvalue，开始查找的索引startindex) ，从尾部开始查找，从右往左

                    说明：方法⑪⑫有兼容问题，

 */

/*
                    //方法：① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩
                    var colors=["red","green"];
                    var len=colors.push("blue","black");  //添加2个新元素，返回新的长度值赋值给len  ，也返回一个新的数组给colors啊！！！！！
                    console.log(colors); // ["red", "green", "blue","black"]
                    console.log(len); //  4
                    var len1=colors.unshift("white","yellow");
                    console.log(colors); // ["white","yellow","red", "green", "blue","black"]
                    console.log(len1); //  6
                    var info=colors.pop();
                    console.log(colors); // ["white","yellow","red", "green", "blue"]
                    console.log(info); //  black
                    var info1=colors.shift();
                    console.log(colors); // ["yellow","red", "green", "blue"]
                    console.log(info1); //  white
                    var str=colors.join();//把colors数组放到一个字符串中
                    console.log(str);//yellow,red,green,blue         得到的已经是字符串了，这个字符串还带着逗号！！因为join()里面没有参数
                    var str1=colors.join("");//把colors数组放到一个字符串中,元素之间""连接
                    console.log(str1);//yellowredgreenblue
                    var str1=colors.join("-");//把colors数组放到一个字符串中,元素之间"-"连接
                    console.log(str1);//yellow-red-green-blue
                    console.log(colors.reverse());//["blue", "green", "red", "yellow"]
                    console.log(colors.sort());//["blue", "green", "red", "yellow"]      //字符串排序是根据英文首字母
                    var numbers=[5,1,7,80,21,-2,-5];
                    console.log(numbers.sort());//[-2, -5, 1, 21, 5, 7, 80]       //数字也是按照字符排序的，所以是看首个字符（数字）
/!*                  数组排序都是按照字符来进行的，数值也会被当做是字符串，
                    字母的排序根据元素的首字母，
                    数值的排序也是根据数值的最高位的值来排序，位数不同的值也会排在一个那么这个排序就错误了，就要在（）里面写上一个可以比较的函数来辅助了*!/
                    console.log(numbers.sort(function (a,b) {return a-b;  }));  // [-5, -2, 1, 5, 7, 21, 80]
                    console.log(numbers.sort(function (a,b) {return b-a;  }));  // [80, 21, 7, 5, 1, -2, -5]
                                /!*     function (a,b) {
                                            return a-b;
                                        }
                                        这个匿名函数就是用来辅助排序的，返回值a-b是正序排列，从小到大排序   ？？？？？？？什么鬼意思啊？？？？？
                                                                        返回值b-a是逆序排序，从大大小*!/

                    console.log(numbers.concat(colors));  // [80, 21, 7, 5, 1, -2, -5, "blue", "green", "red", "yellow"]    把colors添加给numbers
                                   /!* 注意：
                                      上面使用了排序功能已经把数组的改变了！！！！！！！！！！！！！，除join不会改变原来的数组，其他的方法都会改变
                                      而在这里，这个concat方法也没有改变number元素*!/
                    console.log(numbers.slice(0,1));  //    [80]
                    console.log(numbers.slice(-5,5));  //   [7, 5, 1]
                           /!* numbers=[80, 21, 7, 5, 1, -2, -5]
                              m=-5，就是从右边算起第五位，就是7
                              n=5从左边算起，就是-2，但是不会包括-2
                              所以就是[7, 5, 1]
                            *!/

                    console.log(typeof(numbers.slice(0,1)));  //   object，切片*/
    //？？？？问题！！！！为什么有的时候colors数组被改变有的时候没有被改变？？？？？？？？什么鬼情况？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？







/*
    //⑩splice方法

    var colors=["blue", "green", "red", "yellow"];
    console.log(colors.slice(0,8));//["blue", "green", "red", "yellow"];   不越界？？？？？

    var colorssplice=colors.splice(2,0);  //colors.splice 返回一个被删除元素的数组赋值给colorssplice， 这里（2,0）没有区间，就是没有被删除掉元素，
    console.log(colorssplice);//[]     没有被删除元素，返回的即就是一个空函数，原函数还是原状态
    console.log(colors);//["blue", "green", "red", "yellow"]     没有被删除元素，返回的即就是一个空函数，原函数还是原状态
   // var colorssplice1=colors.splice(-2,3);   //-2 是red，3是yellow，  3可以是变得更大， 即使数组的个数已经没有， 它没有越界啊？？？？？？？？？？？？？？
     var colorssplice1=colors.splice(-2,4);   //-2 是red，3是yellow，
    console.log(colorssplice1);// ["red", "yellow"]     这里是被删除的元素
    console.log(colors);//["blue", "green"]              这里是没有被删除的元素


    var colors1=["blue", "green", "red", "yellow"];
    var colorssplice2=colors1.splice(2);  //colors.splice 返回一个呗删除元素的数组赋值给colorssplice， 这里（2），表示从索引2开始到尾部的所有元素删除
    console.log(colorssplice2);//["red", "yellow"]   返回被删除的元素数组
    console.log(colors1);//["blue", "green"]         原数组



    var colors2=["blue", "green", "red", "yellow"];
    console.log(colors2.splice(2,0,"xiaomi","zihua","xiaomizhou"));//[]    在索引2后面添加元素，0表示没有被删除元素，
    console.log(colors2);//["blue", "green", "xiaomi", "zihua", "xiaomizhou", "red", "yellow"]    添加后原函数，
*/




/*
    slice与splice的区别：
            slice()方法用于插入、删除或者替换数组中的元素；
            splice()方法可以提取字符串中的某个部分，并以新的字符串返回被提取的部分；
   用法上：
         slice()方法的参数：
         slice(start,end)
                    slice()方法在string对象和array对象的用法类似。
                    对于array对象来说，slice()方法提取是从start（下标）开始算起，以end（下标）结尾的一段元素（不包括end下标的元素），然后返回新的数组，对原数组没有任何影响。
                    参数为负值，则该参数是从数组的末尾索引开始算起的（-1指的是数组中倒数第一个元素）；
                    参数只有一个时-——slice（2），表示的是从下标为2位置的元素提取到末尾；
                    参数是0时，——slice()，表示的是全部提取，相当于克隆一个新的数组，克隆后两数组之间进行各自的操作，互不影响；

      splice()方法：
      splice（start,count,item）
                    数组从start下标开始，删除count个元素，并且可以在这个位置开始添加个元素；
                    当start,count均为0，表示在数组的最前面插入新的元素；
                    start为负值时，则表示从数组尾部开始算起的位置（-1指的是数组中倒数第一个元素；）
                    splice(start,count)表示从start下标开始删除count个元素；
                    splice（start）表示删除从start下标位置开始到结尾的元素；所以splice(0)是删除所有元素，也是把这个数组的元素全都拿出去生生成一个新的数组。
*/

/*           //面试题：给一个数组a=[1,"yes",3]，一个空数组b，把a数组拷贝到b数组，方法越多越好
           var a =[1,"yes",3],b=[],b1=[],b2=[],b3=[],b4=[],b5=[],b6=[];
           b=a.slice();

           //方法1：slice获取数组的办法
           console.log(b);//[1,"yes",3],   切片不写mn值就是全拷贝了咯，

          //方法2：concat连接数组的办法
           console.log(b1.concat(a));       //把a 加到b后面
          // console.log(a.slice(0,3)+a.pop());       //这个不行！！！切片数组+字符串，得到的是字符串,
                                                   // 问题，可以把字符串直接转化为数组额？，不就是用push在后面增加么，这里用unshift也行，因为b是空的数组啊
          //但是这个切片的方法有点烂，可以把数组的元素遍历出来，然后添加到b中去，就可以得到新的b数组了，

         //方法3：for循环遍历数组的办法
          var len=a.length;
          for(var i=0;i<len;i++){
              b2.push(a[i]);//把a中的元素给b，
          }
          console.log(b2);

         //方法4：splice删除插入替换数组的办法
         b2=a.splice(0);//把a的元素全都给b2，a中没有元素了，
         console.log(b2);//[1,"yes",3]


   // 当start,count均为0，表示在数组的最前面插入新的元素；
         b3=a.splice(0,0,"1","yes","3");//
         console.log(b3);//[]   第二个数是0个元素，所以返回的是空数组

       //方法5这个也不算是办法了，
         b4=a.splice(0,3,"1","yes","3");
         console.log(b4);//["1", "yes", "3"]
         console.log(a);//["1", "yes", "3"]
 */


/*    //方法⑪ indexOf
    //indexOf(要查找的元素searchvalue，开始查找的索引startindex) ，从starindex开始查找元素的，第一次找到元素的下标
   // 返回下标值，不会改变原数组
    var colors=["blue", "green", "red", "yellow","blue", "blue", "green", "red", "yellow","green", "red", "yellow"];
    var blueNumber=colors.indexOf("bule",0);  //bule错了，找不到是-1 没有元素返回的下标是-1！！！！！！！！！！！！
    console.log(blueNumber);//-1
    var blueNumber1=colors.indexOf("blue",0);  //
    console.log(blueNumber1);// 0


    var colors1=[ "green", "red", "yellow","blue", "blue", "green", "red", "yellow","green", "red", "yellow"];
    var blueNumber2=colors1.indexOf("blue",0);  //
    console.log(blueNumber2);// 3
    var blueNumber3=colors1.indexOf("blue");  // 不写下标就是默认从第一个元素开始查找
    console.log(blueNumber3);// 3
    var blueNumber4=colors1.indexOf("blue",5);  //
    console.log(blueNumber4);// -1         没有元素返回的下标是-1！！！！！！！！！！！！！！！！！！！！！！！！！！！！*/


/*    //方法 ⑫lastIndexOf(）
    var colors=["blue", "green", "red", "yellow","blue", "blue", "green", "red", "yellow","green", "red", "yellow"];
    var blueNumber1=colors.lastIndexOf("blue",0);  //
    console.log(blueNumber1);// 0                    从索引为0的元素从右往左查找就是第一个元素，下标为0
    var blueNumber2=colors.lastIndexOf("blue",6);  // 从索引为6的元素green，从右往左查找blue，下标为5
    console.log(blueNumber2);// 5

    var blueNumber3=colors.indexOf("red",6);  //   从索引为6的元素green，从左往左查找red，下标为7
    console.log(blueNumber3);//7
    var blueNumber4=colors.lastIndexOf("red",6);  // 从索引为6的元素green，从右往左查找red，下标为2
    console.log(blueNumber4);// 2*/



    // 说明：方法⑪⑫有兼容问题，
    //如何去使得低版本的浏览器也可以使用这个方法，那就用封装的办法。
    //以下：封装一个方法，来实现indexOf的功能

    function ArrayIndexOf(arr,value) {
        var len=arr.length;
        for(var i=0;i<len;i++){
            if(value===arr[i]){
                return i;
            }
        }
        return -1;  //return，放在for循环外面
    }
    function ArrayLastIndexOf(arr,value) {
        var len = arr.length;
        for (var i = len - 1; i >= 0; i--) {
            if (value === arr[i]) {
                return i;
            }
        }
        return -1;  //return，放在for循环外面
    }
    var colors=[ "green", "red", "yellow","blue", "blue", "green", "red", "yellow","green", "red", "yellow"];
    console.log(ArrayIndexOf(colors,"blue"));//3
    console.log(ArrayLastIndexOf(colors,"blue"));//4



</script>


</body>
</html>